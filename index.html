<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>高中職小論文格式自檢系統（HTML + GPTs 摘要版）</title>
  <style>
    :root{--bg:#f7f7fb;--card:#fff;--ink:#111827;--muted:#6b7280;--accent:#2563eb;--border:#e5e7eb}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,"Noto Sans TC","PingFang TC",sans-serif}
    .wrap{max-width:960px;margin:auto;padding:24px}
    header h1{margin:0 0 4px;font-size:clamp(22px,4vw,28px)}
    header p{margin:0;color:var(--muted)}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:18px;margin-top:14px}
    .row{display:flex;flex-wrap:wrap;gap:12px;align-items:center}
    .pill{background:#eef2ff;border:1px solid #e5e7eb;border-radius:999px;padding:.3rem .6rem;font-size:12px}
    .hint{color:var(--muted);font-size:13px}
    .drop{border:2px dashed #cbd5e1;border-radius:12px;padding:24px;text-align:center;background:#fafafa;margin-top:8px}
    input[type=file]{display:none}
    label.file{display:inline-flex;align-items:center;gap:.6rem;padding:.7rem 1rem;border:1.5px dashed #cbd5e1;border-radius:10px;background:#fff;cursor:pointer}
    button{padding:.7rem 1.1rem;border-radius:10px;border:1px solid #d1d5db;background:#fff;cursor:pointer}
    button.primary{background:var(--accent);color:#fff;border-color:transparent}
    button:disabled{opacity:.5;cursor:not-allowed}
    .ok{color:#065f46;background:#ecfdf5;border:1px solid #a7f3d0;padding:.1rem .5rem;border-radius:999px;font-size:12px}
    .bad{color:#991b1b;background:#fef2f2;border:1px solid #fecaca;padding:.1rem .5rem;border-radius:999px;font-size:12px}
    table{border-collapse:collapse;width:100%}
    th,td{border:1px solid #e5e7eb;padding:8px 10px;text-align:left;vertical-align:top}
    th{background:#f9fafb}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px}
    pre{white-space:pre-wrap;max-height:260px;overflow:auto;background:#f9fafb;border:1px solid #e5e7eb;border-radius:8px;padding:8px}
    nav a{color:#2563eb;text-decoration:none}
    nav a:hover{text-decoration:underline}
    .filetag{font-size:13px;color:#374151;margin:6px 0 0}
    .num{display:inline-flex;align-items:center;justify-content:center;width:22px;height:22px;margin-right:6px;border-radius:999px;background:#eef2ff;border:1px solid #e5e7eb;font-size:12px;color:#374151;font-weight:600}
    .muted{color:#6b7280}
    .badge{margin-top:8px}
  </style>

  <!-- pdf.js（ESM） -->
  <script type="module">
    window.loadPdfjs = async () => {
      const base = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.2.67/";
      const { GlobalWorkerOptions, getDocument } = await import(base + "pdf.min.mjs");
      GlobalWorkerOptions.workerSrc = base + "pdf.worker.min.mjs";
      return { getDocument };
    };
  </script>
  <!-- mammoth.js（DOCX→HTML） -->
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>高中職小論文格式自檢系統</h1>
      <p>小論文格式自檢系統。支援 PDF 與 DOCX。檔案上傳產出檢查報告後，網站會立即刪除檔案，不存檔，保護隱私。</p>
      <div class="badge" id="counterBox" style="display:none">目前累積小論文格式自檢人次：<span id="counter">—</span></div>
      <div class="muted" style="margin-top:12px">
        網站建置：<b>CTVS Library 凡事皆正面</b>。本網站系統僅供教育與非營利用途，著作權歸原權利人所有，嚴禁未經授權之商業使用。<br>
        © 2025 CTVS Library 凡事皆正面 · Email: r91628120@ctvs.ptc.edu.tw
      </div>
    </header>

    <section class="card">
      <div class="row" aria-hidden="true">
        <div class="pill">PDF / DOCX</div>
        <div class="pill">頁數 4–10</div>
        <div class="pill">大小 ≤ 5MB</div>
        <div class="pill">不得含校名／姓名</div>
      </div>

      <details style="margin-top:8px">
        <summary><strong>上傳與資料保存政策（必讀）</strong></summary>
        <ul>
          <li><b>自我檢查工具：</b>僅提供格式檢查與建議，不做存證或投稿。</li>
          <li><b>立即刪除：</b>檔案僅在本機記憶體解析，完成後即釋放；本站不保存。</li>
          <li><b>使用者自行保存：</b>請下載檢查報告或複製檢查檔案摘要。</li>
          <li><b>隱私保護：</b>請勿含個資（校名、姓名、班級）。若偵測到將拒絕檢查。</li>
        </ul>
      </details>

      <div class="row" style="margin-top:8px">
        <input id="consent" type="checkbox" />
        <label for="consent">我已閱讀並同意上述政策，並確認檔案不含 <span class="mono">校名/姓名</span>。</label>
      </div>

      <div id="drop" class="drop" aria-disabled="true">
        <p><strong>拖拉 PDF 或 DOCX 至此</strong> 位置</p>
        <label for="file" class="file">選擇檔案</label>
        <input id="file" type="file" accept=".pdf,.docx" disabled />
        <p class="hint">完成檢查後會立即刪除檔案。</p>
      </div>

      <div class="row" style="margin-top:8px">
        <button id="start" class="primary" disabled>開始檢查</button>
        <button id="clear" disabled>清除</button>
        <!-- ★ 新增：字體字型進階檢查（獨立呼叫 Cloud Run） -->
        <button id="fontCheckBtn" disabled>字體字型進階檢查</button>
        <span id="status" class="hint" role="status" aria-live="polite"></span>
      </div>
    </section>

    <section class="card" id="spec">
      <h2>系統檢查規則（合格標準）</h2>
      <p class="hint">以下為本系統會檢查的小論文格式規則，供老師與學生參考：</p>
      <ol>
        <li>頁數：4–10 頁才合格，少於4或多於10頁視為不通過。</li>
        <li>頁首需含檔名：每頁頁首帶必須顯示檔案名稱（或篇名），否則不通過。</li>
        <li>上傳檔案檔名與篇名一致：上傳檔案之檔名需與頁首篇名相符，不符判定淘汰。</li>
        <li>頁碼：每頁下方中央需有阿拉伯數字頁碼，若缺漏或非連號則不通過。</li>
        <li>邊界：四周邊界至少 2 公分，若小於 2 公分則不通過。</li>
        <li>隱私：正文中不得出現學校名稱或學生姓名，若偵測到則不通過。</li>
        <li>六大段落：必須依序出現「壹、前言 → 貳、文獻探討 → 參、研究方法 → 肆、研究分析與結果 → 伍、研究結論與建議 →陸、 參考文獻」。</li>
        <li>內文引註：需使用「（姓名，年份）」或「姓名（年份）」體例，若未檢出則不通過。</li>
        <li>直接引文長度：單一引文不得超過 50 字（不含標點與空白），超過則不通過。</li>
        <li>參考文獻數量：至少需有 3 筆，若不足則不通過，檢查參考文獻排列錯誤等，不列入計算筆數。</li>
        <li>版面編排：啟發式檢查單行間距、段首縮排一致性，偏離時會提醒不通過。</li>
        <li>封面頁：不得包含封面頁（如校名/指導老師/班級/學號等），若偵測到則不通過。</li>
        <li>標題層次：建議使用清楚的章節層級，例如壹/一/（一）/1/(1) 或 I/A/(A)。</li>
        <li>引用需附出處：直接引文附近應能檢出年份樣式；未附視為不通過。</li>
        <li>圖表規範：圖或表需有編號與標題，上方置左；下方需有「資料來源：…」。</li>
        <li>參考文獻一致性：內文出現的引註應能在參考文獻找到對應。</li>
        <li>文獻來源比例：參考文獻不可全部為純網路來源。</li>
        <li>字體/字型：建議中文新細明體 12pt、英文 Times New Roman 12pt、黑色字體（人工確認或按上方"字體字型進階檢查"按鈕可準確檢查）。</li>
        <li>校外發表/得獎：需以人工或 GPT 小助手協助檢索確認。</li>
      </ol>
      <p class="hint">※ 系統檢查為輔助工具，最終仍需老師人工覆核。</p>
    </section>

    <section id="resultCard" class="card" style="display:none">
      <h3>檢查結果</h3>
      <div id="fileTag" class="filetag"></div>
      <table>
        <thead><tr><th>規則</th><th>結果</th><th>證據 / 說明</th><th>建議</th></tr></thead>
        <tbody id="tbody"></tbody>
      </table>

      <div class="row" style="margin-top:8px">
        <button id="downloadHtml">下載檢查結果（網頁格式）</button>
        <button id="copyJson">複製檢查結果 (給AI助手)</button>
        <button id="downloadJson">儲存檢查結果檔案</button>
        <a id="openGpts" class="primary" href="https://chatgpt.com/g/g-68c6d9e700c88191872154808e0e0e7b-gao-zhong-zhi-xiao-lun-wen-ge-shi-zi-jian-xi-tong" target="_blank" rel="noopener">
          打開AI助手（貼上檢查結果）
        </a>
      </div>
      <pre id="jsonPreview" class="mono" style="margin-top:8px"></pre>
    </section>

    <section class="card" id="teacher-guide">
      <h2>老師／學生導覽</h2>
      <p class="hint">快速理解系統用途、操作流程、課堂導入方式與規則版本。</p>
      <nav style="margin:8px 0 14px">
        <a href="#teacher-howto">如何操作</a> ·
        <a href="#teacher-examples">常見錯誤範例</a> ·
        <a href="#teacher-rules">檢查規則版本對照</a>
      </nav>

      <details id="teacher-howto" open>
        <summary><strong>如何操作（老師／學生）</strong></summary>
        <ol>
          <li>請勾選上傳政策。</li>
          <li>上傳 PDF 或 DOCX。</li>
          <li>按「開始檢查」，查看檢查報告。</li>
          <li>如需更細的字體字型檢查：按「字體字型進階檢查」。</li>
          <li>如需建議：複製 檢查報告 → 打開 AI助手 → 貼上。</li>
        </ol>
      </details>

      <details id="teacher-examples">
        <summary><strong>常見錯誤範例</strong></summary>
        <ul>
          <li><b>缺頁碼：</b>頁尾無置中數字 → 請加入阿拉伯數字連號。</li>
          <li><b>邊界不足：</b>小於 2 公分 → 請調整 Word / PDF 邊界。</li>
          <li><b>段落錯誤：</b>「參考文獻」缺失 → 請補齊六大段落。</li>
          <li><b>引註錯誤：</b>未用（姓名，年份） → 請改為作者(年份)體例。</li>
          <li><b>引文過長：</b>單處超過 50 → 請改述。</li>
          <li><b>參考文獻不足：</b>少於 3 筆 → 請補足。</li>
          <li><b>含個資：</b>文中有校名／姓名 → 請去識別化。</li>
        </ul>
      </details>

      <details id="teacher-rules">
        <summary><strong>檢查規則版本對照</strong></summary>
        <table>
          <thead><tr><th>版本</th><th>日期</th><th>內容</th></tr></thead>
          <tbody>
            <tr>
              <td class="mono">v1.2</td><td>2025-09-15</td>
              <td>方案A每次累加；結果列顯示檔名；頁首檢查改為只檢查檔名位於頁首帶；隱私檢查升級為完整校名樣式。</td>
            </tr>
            <tr>
              <td class="mono">v1.1</td><td>2025-09-14</td>
              <td>新增 PDF 空間檢查（頁首、置中頁碼、邊界 2cm）、DOCX 解析、GAS 計數、引文長度（去標點與空白）。</td>
            </tr>
          </tbody>
        </table>
        <p class="hint" style="margin-top:8px">
          註：PDF 座標依 pdf.js 解析，遇特殊文件可能有誤差；如結果與肉眼觀察不一致，請以老師覆核為準。
        </p>
      </details>
    </section>
  </div>

  <script>
    // ====== 可調參數 ======
    const GAS_WEB_APP_URL = "https://script.google.com/macros/s/AKfycbxUi3g3Yzeu7UQkvHx7Eg6YhQlF6i1zNgH0TwfNKbbHc3ggbkY8oOfKAAGQn76kALpJ/exec";
    const ENABLE_COUNTER = true;
    const CLOUD_RUN_BASE = "https://font-check-api-1009467346209.asia-east1.run.app";
    const CLOUD_RUN_ENDPOINT = CLOUD_RUN_BASE + "/check";

    // ====== UI元素 ======
    const consent = document.getElementById('consent');
    const fileInput = document.getElementById('file');
    const drop = document.getElementById('drop');
    const startBtn = document.getElementById('start');
    const clearBtn = document.getElementById('clear');
    const fontCheckBtn = document.getElementById('fontCheckBtn');
    const statusEl = document.getElementById('status');
    const resultCard = document.getElementById('resultCard');
    const tbody = document.getElementById('tbody');
    const downloadHtmlBtn = document.getElementById('downloadHtml');
    const copyBtn = document.getElementById('copyJson');
    const downloadJsonBtn = document.getElementById('downloadJson');
    const jsonPreview = document.getElementById('jsonPreview');
    const counterBox = document.getElementById('counterBox');
    const counterEl = document.getElementById('counter');
    const fileTagEl = document.getElementById('fileTag');

    // ====== 狀態 ======
    let arrayBuffer = null;
    let fileName = null;
    let fileBase = null;
    let fileExt = null;
    let lastSummaryJSON = null;
    const _rowsBuffer = [];
    let _lastPageCount = 0;

    // 檢查結果編號
    let _ruleCounter = 0;

    // ====== 規則 ======
    const RULES = {
      minPages: 4,
      maxPages: 10,
      maxSizeMB: 5,
      sixSections: ['前言','文獻探討','研究方法','研究分析與結果','研究結論與建議','參考文獻'],
      quoteMaxChars: 50,
      marginCM: 2.0,
      headerBandFactor: 0.6,
      footerBandFactor: 0.6,
      centerWidthPT: 100
    };
    const CM_TO_PT = (cm)=> cm * 72 / 2.54;
    const MARGIN_PT = CM_TO_PT(RULES.marginCM);
    const PUNCTUATION_REGEX = /[，。、．；：、！？—─\-…‧（）()〔〕【】《》〈〉「」『』“”"'\[\]{}<>‧·~`^_=+\|\\/:，,.;:!\?\s]/g;

    // 校名樣式
    const SCHOOL_PATTERNS = [
      /(國立|市立|縣立)[\u4e00-\u9fa5]{0,8}(高級中學|高中|高職|高工|家商|商工|農工|高農|職業學校|中學|國中|小學|大學|科技大學|科大|師範大學|大學附中|實驗高中|高中部)/g
    ];

    // ====== 上傳可用性 ======
    function setUploadEnabled(enabled){
      fileInput.disabled = !enabled;
      const hasFile = !!arrayBuffer;
      startBtn.disabled = !enabled || !hasFile;
      clearBtn.disabled = !enabled || !hasFile;
      // 進階檢查僅接受 PDF
      fontCheckBtn.disabled = !enabled || !hasFile || fileExt!=='pdf';
    }
    consent.addEventListener('change', ()=>{
      setUploadEnabled(consent.checked);
      statusEl.textContent = consent.checked ? '已同意政策，可上傳檔案。' : '請先同意政策。';
    });

    // ====== DnD / 檔案載入 ======
    ['dragenter','dragover'].forEach(ev=>{
      drop.addEventListener(ev, e=>{
        e.preventDefault(); e.stopPropagation();
        if (!fileInput.disabled) drop.classList.add('drag');
      });
    });
    ['dragleave','drop'].forEach(ev=>{
      drop.addEventListener(ev, e=>{
        e.preventDefault(); e.stopPropagation();
        drop.classList.remove('drag');
      });
    });
    drop.addEventListener('drop', e=>{
      if (fileInput.disabled) return;
      const f = e.dataTransfer.files?.[0];
      if (f) handleFile(f);
    });

    fileInput.addEventListener('change', e=>{
      const f = e.target.files?.[0];
      if (f) handleFile(f);
    });

    function baseName(name){ return (name || '').replace(/\.[^.]+$/,'').trim(); }
    async function handleFile(f){
      const ext = (f.name.split('.').pop()||'').toLowerCase();
      if (!['pdf','docx'].includes(ext)){ statusEl.textContent = '僅支援 PDF 或 DOCX'; return; }
      if (f.size > RULES.maxSizeMB * 1024 * 1024){ statusEl.textContent = `檔案超過 ${RULES.maxSizeMB}MB 上限。`; return; }
      fileName = f.name; fileBase = baseName(f.name); fileExt = ext;
      arrayBuffer = await f.arrayBuffer();
      statusEl.textContent = `已選擇：${f.name}（${(f.size/1024/1024).toFixed(2)} MB）`;
      setUploadEnabled(consent.checked);
    }

    clearBtn.addEventListener('click', ()=>{
      fileInput.value=''; arrayBuffer=null; fileName=null; fileBase=null; fileExt=null;
      startBtn.disabled=true; clearBtn.disabled=true; fontCheckBtn.disabled=true;
      resultCard.style.display='none'; tbody.innerHTML='';
      fileTagEl.textContent='';
      statusEl.textContent='已清除選擇。';
      jsonPreview.textContent=''; lastSummaryJSON=null;
      _rowsBuffer.length=0;
    });

    // ====== 主流程（一般檢查） ======
    startBtn.addEventListener('click', async ()=>{
      if (!arrayBuffer) return;
      tbody.innerHTML=''; resultCard.style.display='none'; statusEl.textContent='解析中…';
      _rowsBuffer.length = 0;
      _ruleCounter = 0;

      try{
        if (fileExt === 'pdf'){
          await runPdfChecks(arrayBuffer);
        } else {
          await runDocxChecks(arrayBuffer);
        }

        resultCard.style.display='block';
        fileTagEl.textContent = `此次檢查檔案：${fileName || '(未命名)'}`;
        statusEl.textContent = '完成檢查。';

        // 保留檔案於記憶體（方便之後按進階檢查）
        buildAndShowSummaryJSON({ fileName, pages: _lastPageCount || 0, passFailRows: _rowsBuffer.slice() });

        // 計數
        if (ENABLE_COUNTER) {
          await bumpCounterEveryTime();
          await fetchCounter();
        }
      }catch(err){
        console.error(err);
        statusEl.textContent = '解析失敗：請確認檔案是否有效。';
      }
    });

    // ====== 字體字型進階檢查（獨立按鈕） ======
    fontCheckBtn.addEventListener('click', async ()=>{
      if (!arrayBuffer || fileExt!=='pdf'){
        alert('請先選擇 PDF 檔並勾選同意政策。');
        return;
      }
      try{
        statusEl.textContent = '上傳至 Cloud Run 進行字體檢查…';
        const pdfBlob = new Blob([arrayBuffer], { type: "application/pdf" });
        const data = await fetchCloudRun(pdfBlob, fileName || 'upload.pdf');

        if (data){
          const { pass, suggestion } = normalizeApiResult(data);
          const ev = buildEvidenceString(data);
          addRow('Cloud Run 字體字型檢查', !!pass, ev, suggestion || '請依規範修正字體（中文字體、英文字體、大小、顏色）。');
          resultCard.style.display='block';
          fileTagEl.textContent = `此次檢查檔案：${fileName || '(未命名)'}`;

          // 重新生成摘要（把這一列也算進去）
          buildAndShowSummaryJSON({ fileName, pages: _lastPageCount || 0, passFailRows: _rowsBuffer.slice() });
          statusEl.textContent = 'Cloud Run 檢查完成。';
        }
      }catch(e){
        console.error(e);
        statusEl.textContent = 'Cloud Run 檢查失敗。';
      }
    });

    // ====== Cloud Run 呼叫（你要的 fetchCloudRun） ======
    async function fetchCloudRun(fileBlob, nameForServer){
      const formData = new FormData();
      formData.append("file", fileBlob, nameForServer || "upload.pdf");
      try {
        const res = await fetch(CLOUD_RUN_ENDPOINT, {
          method: "POST",
          body: formData,
        });
        if (!res.ok){
          const t = await res.text().catch(()=> "");
          throw new Error(`API ${res.status} ${res.statusText} ${t}`);
        }
        return await res.json();
      } catch (err) {
        console.error("呼叫 Cloud Run 失敗：", err);
        addRow('Cloud Run 字體字型檢查', false,
          '無法連線或 CORS 被擋，請確認 Cloud Run 已允許跨網域（OPTIONS 與 Access-Control-Allow-Origin）。',
          '請檢查 Cloud Run CORS 設定與 service URL 是否可公開存取。');
        return null;
      }
    }

    // 將 API JSON 標準化
    function normalizeApiResult(data){
      const pass = typeof data.pass === 'boolean'
        ? data.pass
        : (data.summary?.pass ?? data.ok ?? false);
      const suggestion = data.suggestion || data.summary?.suggestion || '';
      return { pass, suggestion };
    }
    function buildEvidenceString(data){
      try{
        const parts = [];
        if (data.summary?.pages) parts.push(`頁數：${data.summary.pages}`);
        if (data.summary?.dominant_fonts) parts.push(`主要字體：${data.summary.dominant_fonts.join('、')}`);
        if (Array.isArray(data.top_fonts)) parts.push('常見字體：' + data.top_fonts.slice(0,6).join('、'));
        if (data.layout?.per_page_margins?.length){
          const first = data.layout.per_page_margins[0];
          parts.push(`第1頁邊界量測：左${first.left} / 右${first.right} / 上${first.top} / 下${first.bottom} pt（門檻≈${(72*2/2.54).toFixed(1)}）`);
        }
        if (Array.isArray(data.fonts) && data.fonts.length){
          parts.push('字體列表（前幾項）：' + data.fonts.slice(0,6).map(f => {
            const n = [f.family, f.name].filter(Boolean)[0] || '(未知字體)';
            const sz = f.size_pt ? `${f.size_pt}pt` : (f.size || '');
            const wt = f.weight || '';
            const clr = f.color || f.fill || '';
            return [n, sz, wt, clr].filter(Boolean).join(' / ');
          }).join('；'));
        }
        if (Array.isArray(data.issues) && data.issues.length){
          parts.push('問題：' + data.issues.slice(0,6).map(it => it.message || it).join('；'));
        }
        if (!parts.length) return typeof data === 'object' ? JSON.stringify(data).slice(0,800) : String(data);
        return parts.join('｜');
      }catch{
        return typeof data === 'object' ? JSON.stringify(data).slice(0,800) : String(data);
      }
    }

    // ====== PDF 檢查（含空間/版面規則） ======
    async function runPdfChecks(buf){
      const { getDocument } = await window.loadPdfjs();
      const pdf = await getDocument({ data: buf }).promise;
      const numPages = pdf.numPages; _lastPageCount = numPages;

      // 1) 頁數
      addRow('頁數 4–10', (numPages>=RULES.minPages && numPages<=RULES.maxPages), `共 ${numPages} 頁`, '若少於4或多於10頁，請修訂篇幅。');

      // 解析頁面與座標
      let fullText = '';
      const headerHasTitle = new Set();
      const bodyHasTitle = new Set();
      const pageNumOkPages = [];
      let sequentialOk = true;

      const headerTitleTexts = [];
      const lineGaps = [];
      const firstXs = [];

      // ★ 只以「第1頁」作為邊界量測基準
      let minLeft=Infinity, minRight=Infinity, minTop=Infinity, minBottom=Infinity;

      const norm = s => (s||'').replace(/\s/g,'').toLowerCase();
      const baseNorm = norm(fileBase||'');

      for (let p=1; p<=numPages; p++){
        const page = await pdf.getPage(p);
        const viewport = page.getViewport({ scale: 1 });
        const W = viewport.width, H = viewport.height;
        const tc = await page.getTextContent();

        const headerBandY = H - (MARGIN_PT * RULES.headerBandFactor);
        const footerBandY = (MARGIN_PT * RULES.footerBandFactor);
        const centerLeft = W/2 - RULES.centerWidthPT;
        const centerRight = W/2 + RULES.centerWidthPT;

        let hasCenterPageNum = false;
        const lineMap = new Map();
        const lineYs = [];

        const txt = tc.items.map(it=>it.str).join('');
        fullText += `\n\n[[PAGE_${p}]]\n` + txt;

        for (const it of tc.items){
          const tr = it.transform; const x = tr[4]; const y = tr[5];
          const w = (typeof it.width==='number')?it.width:0;
          const pure = (it.str||'').trim();
          const pureNorm = norm(pure);

          if (y <= footerBandY && x >= centerLeft && (x+w) <= centerRight){
            if (/^\d+$/.test(pure)) {
              hasCenterPageNum = true;
              if (parseInt(pure,10) !== p) sequentialOk = false;
            }
          }
          if (y >= headerBandY && pure){ headerTitleTexts.push(pure); }
          if (baseNorm && pureNorm.includes(baseNorm)){
            if (y >= headerBandY){ headerHasTitle.add(p); }
            else if (y > MARGIN_PT && y < (H - MARGIN_PT)){ bodyHasTitle.add(p); }
          }

          const inBodyZone = (y > MARGIN_PT) && (y < (H - MARGIN_PT));
          if (inBodyZone){
            const ky = Math.round(y);
            const cur = lineMap.get(ky) || {minX: Infinity};
            if (x < cur.minX) cur.minX = x;
            lineMap.set(ky, cur);
            lineYs.push(ky);

            // ★★★ 邊界量測只在第1頁進行（避免後續頁面內容長短造成誤判）
            if (p === 1){
              const distLeft = x;
              const distRight = W - (x + w);
              const distBottom = y;
              const distTop = H - y;
              if (distLeft < minLeft) minLeft = distLeft;
              if (distRight < minRight) minRight = distRight;
              if (distBottom < minBottom) minBottom = distBottom;
              if (distTop < minTop) minTop = distTop;
            }
          }
        }
        if (hasCenterPageNum) pageNumOkPages.push(p);

        const ys = [...new Set(lineYs)].sort((a,b)=>b-a);
        for (let i=1;i<ys.length;i++){ lineGaps.push(Math.abs(ys[i-1]-ys[i])); }
        firstXs.push(...[...lineMap.values()].map(v=>v.minX).filter(Number.isFinite));
      }

      // 2) 頁首檔名存在（僅頁首帶）
      const missHeaderPages = []; for (let p=1;p<=numPages;p++){ if(!headerHasTitle.has(p)) missHeaderPages.push(p); }
      const wrongPlacement = []; for (const p of bodyHasTitle){ if (!headerHasTitle.has(p)) wrongPlacement.push(p); }
      const headerPass = missHeaderPages.length===0 && wrongPlacement.length===0;
      const headerEvidence = headerPass
        ? '所有頁面之頁首帶均偵測到檔名'
        : [
            missHeaderPages.length ? `缺少頁首檔名頁次：${missHeaderPages.join(', ')}` : '',
            wrongPlacement.length ? `檔名疑似出現在正文而非頁首：${wrongPlacement.join(', ')}` : ''
          ].filter(Boolean).join('；');
      addRow('每頁需在頁首帶包含檔名（非正文區）', headerPass, headerEvidence,
             '請將檔名／篇名設定於頁首帶（建議 10pt 置中）；不可放在正文區。');

      // 2-1) 檔名 vs 頁首篇名一致
      const headerTitleGuess = (() => {
        const n = s => (s||'').replace(/\s/g,'').toLowerCase();
        const filtered = headerTitleTexts.filter(s => n(s).length >= 4);
        const freq = new Map();
        for (const s of filtered){ const k=n(s); freq.set(k,(freq.get(k)||0)+1); }
        let bestKey = '', bestCount=0;
        for (const [k,c] of freq){ if(c>bestCount){ bestKey=k; bestCount=c; } }
        const raw = filtered.find(s => n(s)===bestKey) || '';
        return { norm: bestKey, raw };
      })();
      const fileNorm = (fileBase||'').replace(/\s/g,'').toLowerCase();
      const titleNorm = headerTitleGuess.norm;
      const titleDetected = !!titleNorm;
      const nameTitleConsistent = titleDetected && (titleNorm.includes(fileNorm) || fileNorm.includes(titleNorm));
      addRow('檔案名稱 與 頁首篇名一致性（不符判定淘汰）',
        nameTitleConsistent,
        titleDetected ? `檔案名稱：「${fileBase}」；偵測頁首篇名：「${headerTitleGuess.raw}」` : '未偵測到可辨識的頁首篇名',
        '請將檔名與頁首篇名保持一致；常見作法是兩者皆用小論文篇名。');

      // 3) 頁碼置中
      const pageNumPass = (pageNumOkPages.length === numPages);
      addRow('每頁需有置中頁碼（底端帶）', pageNumPass,
             pageNumPass ? '所有頁底中央皆有頁碼' :
                           `缺少頁碼頁次：${missingRange(pageNumOkPages, numPages)}`,
             '請在頁尾置中放置阿拉伯數字頁碼；建議 10pt。' + (pageNumPass && !sequentialOk ? '（注意：疑似非連號）' : ''));

      // 4) 邊界 2 公分（★ 第1頁為基準）
      const marginPass =
        (minLeft >= MARGIN_PT) && (minRight >= MARGIN_PT) &&
        (minBottom >= MARGIN_PT) && (minTop >= MARGIN_PT);
      const marginInfo = `（以第1頁為基準）估計最小邊界（pt）：左 ${isFinite(minLeft)?minLeft.toFixed(1):'—'}、右 ${isFinite(minRight)?minRight.toFixed(1):'—'}、上 ${isFinite(minTop)?minTop.toFixed(1):'—'}、下 ${isFinite(minBottom)?minBottom.toFixed(1):'—'}（門檻 ≈ ${MARGIN_PT.toFixed(1)}）`;
      addRow('四周邊界 ≥ 2 公分（第1頁為基準）', marginPass, marginInfo, '以第1頁設定為版面基準；請確認邊界至少 2 公分。');

      // 5) 版面編排（單行間距 / 段首縮排）
      const med = median(lineGaps);
      const indentStd = stdev(firstXs);
      const spacingOk = (med>=10 && med<=16);
      const indentOk = (indentStd<=12);
      addRow('版面編排（單行間距 / 段首縮排）',
        spacingOk && indentOk,
        `行距眾數≈${isNaN(med)?'—':med.toFixed(1)}pt；段首一致性(Std)≈${isNaN(indentStd)?'—':indentStd.toFixed(1)}pt`,
        '行距建議為單行；段首（是否縮排）需全篇一致。');

      // 6) 不得有封面頁
      const firstPageText = (()=>{ const m = fullText.match(/\[\[PAGE_1\]\]([\s\S]*?)(\[\[PAGE_|$)/); return m?m[1]:'';})();
      const coverHits = ['封面','學校','指導老師','學生','班級','學號'].filter(k=> firstPageText.includes(k));
      addRow('不得有封面頁（4–10頁）', coverHits.length===0,
             coverHits.length?`第1頁疑似封面頁關鍵字：${coverHits.join('、')}`:'未發現',
             '4–10頁之小論文不應包含封面頁，請移除封面資訊。');

      // 7) 文字規則
      runTextRules(fullText);
    }

    // ====== DOCX 檢查（文字規則） ======
    async function runDocxChecks(buf){
      const { value: html } = await window.mammoth.convertToHtml({ arrayBuffer: buf });
      const fullText = stripHtml(html);
      _lastPageCount = 0;
      addRow('頁數 4–10（DOCX）', true, 'DOCX 無法精確估算頁數，建議匯出 PDF 再檢查空間規則。', '匯出 PDF 以進行頁首/頁碼/邊界檢查。');
      runTextRules(fullText);
    }

    function stripHtml(html){
      const tmp = document.createElement('div'); tmp.innerHTML = html;
      return tmp.textContent || tmp.innerText || '';
    }

    // ====== 通用文字規則 ======
    function runTextRules(fullText){
      const schoolHits = [];
      for (const re of SCHOOL_PATTERNS){
        const m = fullText.match(re);
        if (m && m.length) schoolHits.push(...m);
      }
      addRow('不得含校名/姓名', schoolHits.length===0,
             schoolHits.length ? `偵測到疑似校名：${[...new Set(schoolHits)].join('、')}` : '未發現',
             '請去識別化（以 XXX 取代完整校名）。');

      const sec = RULES.sixSections;
      const idx = sec.map(s => fullText.indexOf(s));
      const hasAll = idx.every(i => i>=0);
      const inOrder = hasAll && idx.join(',') === idx.slice().sort((a,b)=>a-b).join(',');
      addRow('六大段落依序', hasAll && inOrder, hasAll? (inOrder?'順序正確':'找到各段落但順序錯誤') : '有段落缺失',
             '請補齊並按規定順序排列：' + sec.join(' → '));

      const cite1 = /（[^，\n]{1,8}，\s*\d{4}）/g;
      const cite2 = /[^\s，。、]{1,8}（\s*\d{4}）/g;
      const hasCite = (fullText.match(cite1)?.length || 0) + (fullText.match(cite2)?.length || 0);
      addRow('內文引註採 作者-年份', hasCite>0, hasCite?`檢出 ${hasCite} 處`:'未檢出引註樣式', '請使用（姓名，年份）或 姓名（年份）。');

      const quotes = [];
      const zh = fullText.match(/「([^」]+)」/g) || []; zh.forEach(m=>quotes.push(m.replace(/[「」]/g,'')));
      const en = fullText.match(/“([^”]+)”/g) || []; en.forEach(m=>quotes.push(m.replace(/[“”]/g,'')));
      const clean = s => s.replace(PUNCTUATION_REGEX,'');
      const over = quotes.filter(q => clean(q).length > RULES.quoteMaxChars);
      addRow(`直接引文 ≤ ${RULES.quoteMaxChars} 字（不含標點與空白）`, over.length===0, over.length?`超標處：${over.length} 處`:'OK', '請改為摘要轉述，或刪減直接引文。');

      const refStart = fullText.indexOf('參考文獻');
      let refText = refStart>=0 ? fullText.slice(refStart) : '';
      let refCount = 0;
      if (refText){
        const candidates = refText.split(/\n|；|;|\r/g).filter(x=>x.trim().length>0);
        refCount = candidates.filter(x => /(\d{4})|(^\d+\.)|（\d{4}）/.test(x)).length;
      }
      addRow('參考文獻 ≥ 3', refCount>=3, `估計 ${refCount} 筆`, '請補足至少三筆參考文獻。');

      const hLevels = [];
      if(/(^|\n)\s*(壹|貳|參|肆|伍|陸)[\s．.、]/.test(fullText)) hLevels.push('壹/貳/參');
      if(/(^|\n)\s*(一|二|三|四|五|六)[、．.]/.test(fullText)) hLevels.push('一/二/三');
      if(/(^|\n)\s*(（一）|\(一\))/.test(fullText)) hLevels.push('（一）');
      if(/(^|\n)\s*(I|II|III|IV|V|VI)\./.test(fullText)) hLevels.push('I./II.');
      if(/(^|\n)\s*(A|B|C)\./.test(fullText)) hLevels.push('A./B.');
      addRow('標題與次標題層次', hLevels.length>1, hLevels.length?`檢出層級樣式：${hLevels.join('、')}`:'未檢出層級樣式（僅提醒）',
             '建議使用：壹→一→（一）→1→（1）或 I→A→(A) 等層次。');

      const aroundHasYear = (all, idx, len) => {
        const start = Math.max(0, idx-80), end = Math.min(all.length, idx+len+80);
        const win = all.slice(start,end);
        return /（[^，\n]{1,12}，\s*\d{4}）|[^\s，。、]{1,12}（\s*\d{4}）/.test(win);
      };
      const allQuotes = [...(fullText.match(/「[^」]{1,200}」/g)||[]), ...(fullText.match(/“[^”]{1,200}”/g)||[])];
      let missingCite = 0;
      for(const q of allQuotes){
        const i = fullText.indexOf(q);
        if(i>=0 && !aroundHasYear(fullText,i,q.length)) missingCite++;
      }
      addRow('引用原文需註明出處（≤50字）', missingCite===0,
             missingCite===0 ? '抽樣檢查：引文附近含年份樣式' : `有 ${missingCite} 處引文附近未見年份樣式`,
             '直接引文需加引號且 ≤50 字並附出處；間接引述也應附出處。');

      const figCount = (fullText.match(/(^|[^\u4e00-\u9fa5])圖\s*\d+[\s．.、]/g)||[]).length;
      const tabCount = (fullText.match(/(^|[^\u4e00-\u9fa5])表\s*\d+[\s．.、]/g)||[]).length;
      const srcCount = (fullText.match(/資料來源[:：]/g)||[]).length;
      const totalFT = figCount + tabCount;
      const missFT = totalFT>0 ? Math.max(0, totalFT - srcCount) : 0;
      addRow('圖表需有標號/標題與來源', missFT===0, `檢出圖/表 ${totalFT} 項；缺少來源 ${missFT} 項`, '圖表上方置左標號+標題；下方標示「資料來源：…」。');

      const citations=(fullText.match(/（[^，\n]{1,8}，\s*\d{4}）/g)||[]).map(s=>s.replace(/[（）\s]/g,''));
      let linked=0; if(refText){ for(const c of citations){ const core=c.replace(/，/g,''); if(refText.includes(core)) linked++; } }
      const unlinked = Math.max(0, citations.length - linked);
      addRow('參考文獻與內文引註一致性', unlinked===0,
             `引註共 ${citations.length} 筆；有對應 ${linked} 筆；未對應 ${unlinked} 筆`,
             '內文出現的引用都應在參考文獻出現；未引用者不得列入參考文獻。');

      let webCount=0;
      if (refText){
        const lines = refText.split(/\n+/).map(s=>s.trim()).filter(Boolean);
        webCount = lines.filter(s => /(https?:\/\/|doi\.org|取自|Available at|網址)/i.test(s)).length;
      }
      const nonAllWebPass = (refCount===0) ? false : (webCount < refCount);
      addRow('參考文獻來源不可全為網路', nonAllWebPass,
             `估計總數 ${refCount}；網路來源 ${webCount}`,
             '若僅有 3 筆，至少 1 筆需為非純網路（如書籍、期刊、教科書等）。');

      addRow('字體/字型規範（需人工確認）', true,
             '建議：中文新細明體 12pt；英文 Times New Roman 12pt；黑色字體；中文全形／英文半形標點。',
             '請抽查多處段落是否符合。');

      addRow('作品名稱是否已於校外發表/得獎（需人工/GPT）', true,
             `請以關鍵字「${fileBase||'小論文篇名'}」搭配比賽名稱/學校名稱搜尋確認。`,
             '點右上「打開AI助手」→ 貼上檢查摘要 JSON，請 GPT AI小助手 協助檢索。');
    }

    // ====== 工具 ======
    const median = arr => {
      const a = arr.filter(x=>Number.isFinite(x)).slice().sort((x,y)=>x-y);
      if (!a.length) return NaN;
      const n=a.length; return n%2 ? a[(n-1)/2] : (a[n/2-1]+a[n/2])/2;
    };
    const stdev = arr => {
      const a = arr.filter(x=>Number.isFinite(x));
      const n=a.length; if(n<2) return NaN;
      const mean=a.reduce((t,x)=>t+x,0)/n;
      const v=a.reduce((t,x)=>t+(x-mean)*(x-mean),0)/n;
      return Math.sqrt(v);
    };

    function missingRange(okPages, total){
      const ok = new Set(okPages); const miss = [];
      for (let i=1;i<=total;i++){ if(!ok.has(i)) miss.push(i); }
      return miss.length ? miss.join(', ') : '—';
    }
    function addRow(rule, pass, evidence, suggestion){
      const tr = document.createElement('tr');
      const badge = pass ? '<span class="ok">通過</span>' : '<span class="bad">未通過</span>';
      tr.innerHTML = `
        <td><span class="num">${++_ruleCounter}</span>${rule}</td>
        <td>${badge}</td>
        <td>${evidence||''}</td>
        <td>${suggestion||''}</td>
      `;
      tbody.appendChild(tr);

      const map = {
        '頁數 4–10': {rule_id:'file.pages', category:'檔案規格', severity:'critical'},
        '每頁需在頁首帶包含檔名（非正文區）': {rule_id:'header.filename_in_header', category:'頁首', severity:'critical'},
        '檔案名稱 與 頁首篇名一致性（不符判定淘汰）': {rule_id:'filename.title_consistency', category:'命名', severity:'critical'},
        '每頁需有置中頁碼（底端帶）': {rule_id:'footer.pagenum', category:'頁碼', severity:'critical'},
        '四周邊界 ≥ 2 公分（第1頁為基準）': {rule_id:'layout.margins', category:'版面', severity:'major'},
        '版面編排（單行間距 / 段首縮排）': {rule_id:'layout.spacing', category:'版面', severity:'major'},
        '不得有封面頁（4–10頁）': {rule_id:'file.coverpage', category:'檔案規格', severity:'critical'},

        '不得含校名/姓名': {rule_id:'privacy.no_school_or_name', category:'隱私', severity:'critical'},
        '六大段落依序': {rule_id:'structure.sections_order', category:'結構', severity:'critical'},
        '內文引註採 作者-年份': {rule_id:'references.citation_style', category:'參考文獻', severity:'major'},
        [`直接引文 ≤ ${RULES.quoteMaxChars} 字（不含標點與空白）`]: {rule_id:'quotes.limit', category:'引文', severity:'major'},
        '參考文獻 ≥ 3': {rule_id:'references.count', category:'參考文獻', severity:'critical'},

        '標題與次標題層次': {rule_id:'structure.headings', category:'結構', severity:'major'},
        '引用原文需註明出處（≤50字）': {rule_id:'references.citation_required', category:'參考文獻', severity:'critical'},
        '圖表需有標號/標題與來源': {rule_id:'figures.tables', category:'圖表', severity:'major'},
        '參考文獻與內文引註一致性': {rule_id:'references.consistency', category:'參考文獻', severity:'critical'},
        '參考文獻來源不可全為網路': {rule_id:'references.non_all_web', category:'參考文獻', severity:'critical'},
        '字體/字型規範（需人工確認）': {rule_id:'style.font', category:'版面', severity:'major'},
        '作品名稱是否已於校外發表/得獎（需人工/GPT）': {rule_id:'external.duplicate_check', category:'人工檢查', severity:'minor'},

        '頁數 4–10（DOCX）': {rule_id:'file.pages.docx', category:'檔案規格', severity:'minor'},
        'Cloud Run 字體字型檢查': {rule_id:'fontcheck.cloudrun', category:'字體字型', severity:'major'}
      };
      const meta = map[rule] || {rule_id:'misc', category:'其他', severity:'minor'};
      _rowsBuffer.push({
        rule_id: meta.rule_id, category: meta.category, severity: meta.severity,
        pass, evidence: typeof evidence==='string' ? {note: evidence} : (evidence||null),
        suggestion: suggestion || null
      });
    }

    // ====== 檢查摘要 JSON ======
    function buildAndShowSummaryJSON({ fileName='paper', pages=0, passFailRows=[] }={}){
      const weight = x => x.severity==='critical' ? 2 : (x.severity==='major' ? 1 : 0.5);
      const maxScore = passFailRows.reduce((a,x)=>a+weight(x),0) || 1;
      const score = Math.round(passFailRows.reduce((a,x)=>a+(x.pass?weight(x):0),0) / maxScore * 100);
      const hasCriticalFail = passFailRows.some(x => !x.pass && x.severity==='critical');
      const status = hasCriticalFail ? 'revise' : 'pass';

      const summary = {
        meta: {
          report_id: (crypto.randomUUID?.() || String(Math.random()).slice(2)),
          generated_at: new Date().toISOString(),
          file: { name: fileName, pages, type: fileExt },
          rules_version: 'v1.3'
        },
        summary: {
          score,
          totals: { checks: passFailRows.length, pass: passFailRows.filter(x=>x.pass).length, fail: passFailRows.filter(x=>!x.pass).length },
          status
        },
        checks: passFailRows.map(x=>({
          rule_id: x.rule_id, category: x.category, severity: x.severity,
          pass: x.pass, evidence: x.evidence || null, suggestion: x.suggestion || null
        }))
      };
      lastSummaryJSON = summary;
      jsonPreview.textContent = JSON.stringify(summary, null, 2);
    }

    // ====== 下載 / 複製 ======
    downloadHtmlBtn.addEventListener('click', ()=>{
      const html = `<!doctype html><meta charset="utf-8"><title>小論文檢查報告</title>${document.querySelector('#resultCard').outerHTML}`;
      const blob = new Blob([html], {type:'text/html;charset=utf-8'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'paper-check-report.html'; a.click();
      URL.revokeObjectURL(a.href);
    });
    copyBtn.addEventListener('click', async ()=>{
      if (!lastSummaryJSON){ alert('尚未產生檢查摘要。'); return; }
      await navigator.clipboard.writeText(JSON.stringify(lastSummaryJSON, null, 2));
      alert('已複製檢查摘要 JSON，前往 GPT 後直接貼上即可。');
    });
    downloadJsonBtn.addEventListener('click', ()=>{
      if (!lastSummaryJSON){ alert('尚未產生檢查摘要。'); return; }
      const blob = new Blob([JSON.stringify(lastSummaryJSON, null, 2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = (lastSummaryJSON.meta?.file?.name || 'paper') + '.summary.json';
      a.click();
      URL.revokeObjectURL(a.href);
    });

    // ====== GAS 累積人次 ======
    async function bumpCounterEveryTime(){
      try{
        await fetch(GAS_WEB_APP_URL, {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({ action: 'increment', site: 'essayguard' })
        });
      }catch(e){ console.warn('GAS increment failed', e); }
    }
    async function fetchCounter(){
      try{
        const res = await fetch(GAS_WEB_APP_URL + (GAS_WEB_APP_URL.includes('?')?'&':'?') + 'action=get&site=essayguard', {headers:{'Accept':'application/json'}});
        const text = await res.text();
        let data; try { data = JSON.parse(text); } catch { data = {}; }
        if (typeof data.count === 'number'){
          counterEl.textContent = data.count.toLocaleString();
          counterBox.style.display = 'block';
        } else {
          counterBox.style.display = 'block';
          counterEl.textContent = '暫不可用';
          console.warn('Counter response:', text);
        }
      }catch(e){
        counterBox.style.display = 'block';
        counterEl.textContent = '暫不可用';
        console.warn('GAS get failed', e);
      }
    }
    if (ENABLE_COUNTER) fetchCounter();
  </script>
</body>
</html>